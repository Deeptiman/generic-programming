## Golang Generic

// https://go.dev/play/p/d277nCZRUX5

- Golang released generic programming with a specific goal for developers to write a standard set of types
  to utilize as type parameters for functions and type structs. The syntax to write generic type comes
  with a `func F[T any] (p T){ ... }` that can be used to declare common types, and the function arguments
  will use the set of types as parameters. Also, types can have type parameters list `type O[T any] struct.`
  We'll see more examples of the syntax of generic structure in the course of this article.


Why Generic types in Golang is so important?
- Golang is known to have a more simplistic code structure than other programming languages. The code syntax and type structure
allow developers to write clean code to improve readability. Golang modular code writing depends on the developer's structure of
functions and types to be reusable by other package modules. To achieve generic code templating in Golang, it's essential to have
generic type syntax to write effective functions to be used by common type sets. The generic code structure improves the design thinking
to write arbitrary functions for a critical implementation to create a common package module. Also, developers must understand the SOLID design
principle before jumping toward the generic design. It encourages arranging the GO programs to achieve a single-purpose design with the package
modules to work together.


SOLID principle design with interface

Interface represents any type in Go. It's best to define an interface with a function signature that any type can implement as an abstraction
to the package module. The interface provides segregation design principles that each type takes advantage of the method signature to write the
underlying function implementation based on the type.


Example:

Let's take an example of a simple Login package design. There are two user type logins { Employee, Customer }, to the Go applications, and
each type will do the login differently than the other. As the first approach, let's design the interface with the Login method signature.


`````````go
type Auth interface {
    Login(id, passwd string) error
}
`````````

The Auth interface defines a simple Login method with `id` and `password` parameters and returns an error. The `Employee` and `Customer`
types can utilize the `Auth` interface to write the implementation for Login.


````````go
type Employee struct {}

func newEmployee() Auth {
    return &Employee{}
}

func (e *Employee) employeeLogin(id, passwd string) error {
    // do employee login with the proper auth mechanism.
    return nil
}

func (e *Employee) Login(id, passwd string) error {
    fmt.Println("Employee login")

    if e.employeeLogin(id, passwd) != nil {
        return fmt.Errorf("employee login failed, id=%s", id)
    }

    return nil
}

type Customer struct {}

func newCustomer() Auth {
    return &Customer{}
}

func isLicenseEnabled(id string) bool {
    // complete code is not necessary
    return true
}

func (c *Customer) customerLogin(id, passwd string) error {
    // do customer login with the proper auth mechanism.
    return nil
}

func (c *Customer) Login(id, passwd string) error {
    fmt.Println("Customer login")

    if c.customerLogin(id, passwd) != nil {
        return fmt.Errorf("customer login failed, id=%s", id)
    }

    if isLicenseEnabled(id) {
        return nil
    }

    return fmt.Errorf("customer license is not enabled, id=%s", id)
}
````````


<< diagram >>

``````

 type Auth interface {
    Login(id, passwd string) error
 }    

 func (Employee) Login(id, passwd string) {}
 func (Customer) Login(id, passwd string) {}


In the example, the `Login` function use case is written differently for the `Employee` and `Customer` types.
The code structure shows by applying the interface segregation principle, each type can isolate the function
use case.

The `Auth` interface defines a single responsibility design by providing a single method signature. This common interface pattern is used widely in Go programs
for better maintainability and reusability of the package module and has a strict correlation among types to utilize the signatures and parameters of the methods.
But what if we have a use case to restrict the `Login` function to only a few types [Employee, Customer], and the caller MUST pass the parameters with the defined types?
Then, `interface` will not be the right approach to the problem.

We will dive into a similar kind of problem in the course of this article and how Golang generic will be the right way to implement the design.


Generic Design

The function parameters and arguments are instantiated in generic programming as a singular type to satisfy one common use case.
In Go 1.18+, the interface design allows the forming of a set of unions with non-interface types. It will be permitted as type parameters
to be used as function arguments as any other type.

Let's example of the Login function and refactor with Generic Type sets.

   func(Employee) Login(id, passwd string) error { return nil }
   func(Customer) Login(id, passwd string) error { return nil }

  We have two types to write as abstract data types, so we can define a new interface type to unionize the non-interface types.


   type AuthParameter interface {
   	    Employee | Customer | Admin // Added additional Admin struct type to explain better on the design
   }

  The `AuthParameter` creates an abstract data type better known as "type parameter". And it can use as type argument in the `Login` function.


  type Login[P AuthParameter] func(ctx context.Context, p P) error

  The `Login` function creates a generic function signature with `AuthParameter` as a type-parameter used as type argument P. Also, we can add as many
  type parameters to define an effective function signature as possible.

  Let's try adding one more type parameter that'll work as a return value for the function.


  type Login[P AuthParameter, T AuthClaimResponse] func(ctx context.Context, p P) (T, error)

  The new type parameter `AuthClaimResponse` in the modified function signature will work as a return type argument. Again, non-interface type can be
  anything to specify with the type parameter to apply to the use case.

  `````````
  type AuthClaimResponse interface {
  	*GeneralClaimResponse | *AdminClaimResponse
  }
  `````````

 `````````````````````
  type GeneralClaimResponse struct {
  	Id         string
  	Token      string
  	License    string
  	MemberType MemberType
  	*ErrorResponse
  }

  type AdminClaimResponse struct {
  	Id         string
  	Token      string
  	ACL        ACL
  	MemberType MemberType
  	Active     bool
  	*ErrorResponse
  }
  ``````````````````

    Now, let's look at the refactored `Login` function with generic programming and the problem we solve with the previous design.

    In the first code snippet for the `Employee` type, the `Login` set the type-parameter for the return arguments with `GeneralClaimResponse` and the implementation
    of the `employeeLoginFn` remains internal to the type and can process the inputs to return the required `GeneralClaimResponse` to the caller.

    `````````````````````
    req := Employee{AuthReq: AuthReq{Id: id, Password: password}}
    loginFn := Login[Employee, *GeneralClaimResponse](employeeLoginFn)
    employeeLoginFn := func(ctx context.Context, emp Employee) (*GeneralClaimResponse, error) {
        // TODO: do something with the function inputs
        return &GeneralClaimResponse{}, nil
    }
    `````````````````````

    For another concrete type, `Admin,` the type-parameter is declared with `AdminClaimResponse` to be used as the return value for the Login function. And for
    `adminLoginFn` function implementation remains independent of the other types.

    `````````````````````
    req := Admin{AuthReq: AuthReq{Id: id, Password: password}}
    loginFn := Login[Admin, *AdminClaimResponse](adminLoginFn)
    adminLoginFn := func(ctx context.Context, admin Admin) (*AdminClaimResponse, error) {
        // TODO: do something with the function inputs
        return &AdminClaimResponse{}, nil
    }
    `````````````````````

    Both types have their own `Login` function definition, and we need middleware to process them individually without additional value manipulation with type inputs.

    // Login function pass to the middleware
    resp, err := authMiddleware(ctx, loginFn, req)

    func authMiddleware[P AuthParameter, R AuthClaimResponse](
    	ctx context.Context,
    	loginFn Login[P, R], authReq P) (R, error) {
    	var retry = 5
    	return loginWithRetry(ctx, retry, loginFn, authReq)
    }

    func loginWithRetry[P AuthParameter, R AuthClaimResponse](
    	ctx context.Context,
    	retry int,
    	loginFn Login[P, R], authReq P) (R, error) {
    	resp, err := loginFn(ctx, authReq)
    	if err != nil {
    		if retry--; retry >= 0 {
    			return loginWithRetry(ctx, retry, loginFn, authReq)
    		}

    		return nil, err
    	}

    	fmt.Println("login successful ")

    	return resp, nil
    }

    We see a retry mechanism inside the middleware applied to the `Login` function. As the function definition is passed from the caller with the
    proper type arguments, the function can be retried by comparing each attempt with the error value. This is the least we can do for the `Login` function
    in the middleware; otherwise, the generic design doesn't yet support accessing field items of the `type` declared in the type argument.

    What problem did we solve with the Generic `Login` function design?
    - As we can see, the refactored `Login` function has type parameters with any concrete types, and each of them can define the implementation with their required
    type and prepare different outputs for the return arguments.
    - The generic retry component in the middleware allows the design to add a common retriable mechanism for the `Login` function.
    - The generic type parameters will allow adding any other concrete type to the design without intervening with core structural design changes.

 Constraints

  The type-parameter design adds a union of type sets to define an abstract data type, but we can't really know what types are involved in the set and how
  they operate to perform specific tasks. What if There is a requirement to write an arbitrary function to compare the type elements? It's essential to know the
  supported flavors of the types. Although the goal is to achieve a generic template to hide the type's behaviors, in some cases, it's good to use predictive type
  sets to add computational flexibility to the generic function. This is where Golang constraint design comes with defined type parameters to perform computation
  with Go operators.

  For example:

   package main

   import (
   	"fmt"
   	"golang.org/x/exp/constraints"
   )

   func main() {
   	sum1 := computeSum([]int{1, 2, 3, 4, 5})
   	fmt.Println("sum of integers = ", sum1)

   	sum2 := computeSum([]uint32{11, 21, 34, 41, 56})
   	fmt.Println("sum of unsigned integers = ", sum2)

   	result := compareFloats([]float64{1.5, 3.2, 4.7, 5.2, 8.9, 7.1, 6.3})
   	fmt.Println("float values greater than 5.0 = ", result)
   }

   func computeSum[P constraints.Integer](p []P) P {
   	var s P
   	for _, t := range p {
   		s += t
   	}
   	return s
   }

   func compareFloats[P constraints.Float](p []P) []P {
   	e := make([]P, 0, len(p))
   	for _, t := range p {
   		if t >= 5.0 {
   			e = append(e, t)
   		}
   	}
   	return e
   }

   In the example above, we imported the constraint package that provides known primitive data types declared as type parameters and that we can use to apply
   operators to perform math comparisons with the types. The constraint package allows flexibility to be compatible with the operators as the type elements are known.

   Also, we can define our constraint type parameters to perform a specific operation in the generic function. Let's take a simple use case to convert an array of
   strings to lowercase. In usual type-parameter declarations, we never know whether the type T is a string, and it's impossible to do the conversion. To overcome the
   design restriction, we can write an interface type `StringCases` to define the "ToLower() string" method signature, and then any concrete type can utilize the
   interface function internally to do string conversion. In the generic function, we can use the `StringCases` interface type as a type parameter to allow the type
   arguments to call the "ToLower()" function.

   package main

   import (
      "fmt"
      "strings"
   )

   func main() {
        str := ToLower([]res{{"ABC"}, {"DEF"}, {"PQR"}, {"XYZ"}})
        fmt.Println("convert string to lowercase = ", str)
   }

   type StringCases interface {
   	ToLower() string
   	ToUpper() string
   }

   type res struct {
   	x string
   }

   func (p res) ToLower() string {
   	return strings.ToLower(p.x)
   }

   func (p res) ToUpper() string {
   	return strings.ToUpper(p.x)
   }

   func ToLower[T StringCases](s []T) (ret []string) {
   	for _, v := range s {
   		ret = append(ret, v.ToLower())
   	}
   	return ret
   }

 Type inference

  Type inference is a technique to deduce the number of expressions in a function type argument by declaring structural type or structural constraints as type parameters.

  Let's take an example with structural type parameter to infer type argument. The list of `Employee` structural types declared with constraints type inference to omit the type argument for each type.


  func GetEmployeeRecord[P ~[]E, E Employee](p P, i int) Employee { ... }

  list := []Employee{{Id: 1, Salary: 10000}, {Id: 2, Salary: 25000}, {Id: 3, Salary: 48000}}
  GetEmployeeRecord(list, 1)

  In the function call, the list value is passed as a type argument, and the `[]Employee` type is identical to type parameter P because the underlying type is valid
  with the type `Employee.`

  The tilde ~ symbol negates any other type than type E --> Employee. In this function, type inference is archived with constraints type inference technique.
  We could define a structural constraint type P by doing the inference with structural type parameter E in the type parameter.


  Also, we could do the constraint type inference with another type defined in the type parameter whose underlying type is the same type.

  type Organization interface {
      Employee | Customer
  }

  func GetEmployeeRecord[P ~[]E, E Organization](p P, i int) Employee { ... }

  In this example, the type parameter E underlying type is Employee, which is valid for declaring the constraint type inference P as another type parameter and
  will match with the function type arguments.

  Without type inference?

  If we don't use type inference, we need to define an explicit type argument for each type parameter. The generic function writing becomes repetitive in specifying
  the same type expression for each type parameter.

  func GetEmployeeRecord[P []Employee, E Employee](p P, i int) Employee { ... }

  type records []Employee
  list := []Employee{{Id: 1, Salary: 10000}, {Id: 2, Salary: 25000}, {Id: 3, Salary: 48000}}
  GetEmployeeRecord[records, Employee](list, 1)

  The benefit of type inference in generic function writing is more of a clean code structure for better readability. It doesn't add code efficiency but improves the
  grammar of generic code syntax.


 What does tilde ~ symbol means to the type-parameters declaration?

   - The type arguments MUST satisfy the underlying types defined in the type parameters, and in some instances, the type arguments must pass only the permitted types.
   So, Go generic provides ~ symbol syntax to the type-parameter to add some validation against the `A,` which only supports type T, P, or E.


   type A interface {
      ~T | ~P | ~E
   }

   For example:

    package main

    import "fmt"

    type Number int

    type Integer interface {
    	~int | ~int8 | ~int16
    }

    func toNumber[T Integer](t T) T {
    	return t * 2
    }

    func main() {
    	n := toNumber(5)
    	fmt.Println("n = ", n)

    	x := toNumber(Number(6))
    	fmt.Println("x = ", x)
    }

    In the above example, the `Integer` type parameters have a set of `int` types with ~sign to specify that all the type arguments for `toNumber()` MUST pass the
    `int` type values to compute the result successfully. Also, we can see another type definition `Number` uses the type cast technique to pass the int value,
    which is perfectly fine as the ~sign allows the type to be compatible with the required type.

    But if we remove the ~sign from the `int` type, then the `Number` type will not be supported because then the compiler stops checking for the additional type
    association that the type is actually an int type.

    type Integer interface {
         int | ~int8 | ~int16
    }

    Error: Number does not satisfy Integer (possibly missing ~ for int in Integer)


    Summary:

    - To prepare this article, I thoroughly researched the Google Go generic proposal on type parameters. The docs provide a wide variety of syntax to write type
    parameters and function arguments in Go generic code for faster readability. There will be many use cases to write common generic functions utilized by many types,
    and extending the module to any future type means including the new type to the type set. To highlight one use case with concurrency and generic code structure to
    write a worker pool that can facilitate the type parameter and run the worker function with the function type arguments. The significance of a generic worker pool
    is that only code one module requires tuning for optimization and performance and extending to any future type will support the underlying type set.


    - The requirement of generic design MUST be minimal in any application package module because if programmers try to implement generic types for most functions,
    there is compilation cost that, for each underlying type in type-sets, the compiler validates the function inline separately.


    - The generic doesn't support identifying the underlying types with a type switch. If there is a constraint type ~T and underlying types int, string, it's impossible to know
      the type of T that is currently involved in the generic function.

    type T interface { ~int | ~string }

    func matchType[P T](x P) {
        switch x.(type) { // cannot use type switch on type parameter value x (variable of type P constrained by T)
            case int:
            case string:
        }
    }

    The generic function panics because the type argument x is actually constrained with type T. But if we make an adjustment with x by doing type conversion with an
    empty interface, then the compiler understands the type argument as `any` type to choose the matching case.

     func matchType[P T](x P) {
        switch (interface{{})(x).(type) { // VALID
            case int:
            case string:
        }
     }

    - We can't do the conversion from one type parameter to another, so even if both type parameters relate to the same underlying type, the comparison is still impossible
    to know if the types are identical.

        func someFunc[T1, T2 any](x T1, y T2) {
            T1(y) // incompatible
            p := (interface{})(y).(T1) // VALID
        }


   Conclusion

    The article highlighted most of the features outlined in the Go generic design. The constraints type inference is the major key component of the Go generic that
    keeps the generic function more abstract and readable. I have also summarized the issues and missing features with the current design elements that still need to
    evolve, considering all the aspects of generic, which are supported by languages like C++ and Java. The built-in packages require a generic version to provide more
    standard library functions for programmers to call from the application rather than implementing on their own from the application package module. The constraints
    package is limited to some primitive types and needs to be upgraded with more underlying type support. Many other design ideas and issues are discussed in detail
    in the proposal doc, which I didn't cover, but feel free to read it.

   Also, I have committed a generic example module in my GitHub; please feel free to clone and execute it on your machine.



==========

// https://go.dev/play/p/DvJt4-rnTN5

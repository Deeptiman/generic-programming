## Golang Generic

// https://go.dev/play/p/d277nCZRUX5

- Golang releases generic programming with a specific goal for developers to write common set of types
to utilize as types parameters for functions and type struct. The syntax to write generic type comes
with a `func F[T any] (p T){ ... }` that can be use to declare common types and the function arguments 
will use the set of types as parameters. Also, types can have type parameters list `type O[T any] struct`. 
We'll see the more examples on syntax of generic structure in the course of this article.

Why Generic types in Golang is so important?
- Golang is known to have simplistic code structure than other programming languages. The code syntax, type
structure allows developers to write clean code to improve readability. Golang modular code writing depends
on the developer how to structure functions and type to be reusuable by other package modules. To achive generic
code templating in Golang, it's essential to have generic type syntax to write effective functions to be use by
common type sets. The generic code structure improves the design thinking to write arbitary functions for a
critical implementation to create common package module. Also, before jumping towards the generic design developers
must understand the SOLID design principle. It encourages to arrange the GO programs to achive a single purpose design 
with the package modules to work together.

SOLID principle design with interface

interface represents any types in Go. It's best to define an interface with funcion signature that any type can implement
as abstraction to the package module. interface provides segregation design principles that each type take advantage of the
method signature to write the underlying function implementation based on the type.

Example:

Let's take an example of simple Login package design. There are two users type logins { Employee, Customer } to the
Go applications and each type will do the login differently than the other. As first approach let's design the interface
with the Login method signature.

`````````go
type Auth interface {
    Login(id, passwd string) error
}
`````````

Auth interface defines a simple Login method with `id`, `passwd` parameters and return error. And 
`Employee` & `Customer` type can utilize `Auth` interface to write the implementation for Login.

````````go
type Employee struct {}

func newEmployee() Auth {
    return &Employee{}
}

func (e *Employee) employeeLogin(id, passwd string) error {
    // do employee login with the proper auth mechanism.
    return nil
}

func (e *Employee) Login(id, passwd string) error {
    fmt.Println("Employee login")

    if e.employeeLogin(id, passwd) != nil {
        return fmt.Errorf("employee login failed, id=%s", id)
    }

    return nil
}

type Customer struct {}

func newCustomer() Auth {
    return &Customer{}
}

func isLicenseEnabled(id string) bool {
    // complete code is not neccessary
    return true
}

func (c *Customer) customerLogin(id, passwd string) error {
    // do customer login with the proper auth mechanism.
    return nil
}

func (c *Customer) Login(id, passwd string) error {
    fmt.Println("Customer login")

    if c.customerLogin(id, passwd) != nil {
        return fmt.Errorf("customer login failed, id=%s", id)
    }

    if isLicenseEnabled(id) {
        return nil
    }

    return fmt.Errorf("customer license is not enabled, id=%s", id)
}
````````

In the example, the `Login` function usecase is written differently for `Employee` & `Customer` type. 
The code structure shows by applying interface segregation principle each type can isolate the function 
usecase. The `Auth` interface defines single responsibility design by providing single method signature.
This common interface pattern used widely in Go programs for better maintainability and reusability of the
package module and have strict correlation among types to utilize the methods signatures and parameters.
The interface in Go implicit to `any` type to allow to convert the object into a concrete type. But it 
doesn't create contraint type to restrict the any other type to access the method signature. What it means
is before release Go generic interface is kind of universal model to all the types. And 




// https://go.dev/play/p/DvJt4-rnTN5

Complete code can be found at Github



Example: Let's try to design a Login middleware that'll be accessed by multiple models. 

Employee model

<< Employee structure >>

Customer model

<< Customer structure >>

Admin model

<< Admin structure >>

If we take closer look every model is embedded with AuthReq structure to validate the existence of records
in db and authenticate the actor within the cluster. We can create a `Type sets` using an interface to combine
all these model into one generic type. 

````````````````````````go
type AuthParameter interface {
	Employee | Admin | Customer
}
````````````````````````

The `AuthParameter` interface designs a type sets [P AuthParameter] with [Employee, Admin, Customer] models. 
This means the declaration [P AuthParameter] will be use in any method signatures. 






to introduce common set of types that developers
can utilize to write singular reusable code.

to define a set of types with type parameters and type inference.
The 

with type parameters for functions and interface types. 
The generic structure defines the types  
## Golang Generic

// https://go.dev/play/p/d277nCZRUX5

- Golang released generic programming with a specific goal for developers to write a standard set of types
  to utilize as type parameters for functions and type structs. The syntax to write generic type comes
  with a `func F[T any] (p T){ ... }` that can be used to declare common types, and the function arguments
  will use the set of types as parameters. Also, types can have type parameters list `type O[T any] struct.`
  We'll see more examples of the syntax of generic structure in the course of this article.


Why Generic types in Golang is so important?
- Golang is known to have a more simplistic code structure than other programming languages. The code syntax and type structure
allow developers to write clean code to improve readability. Golang modular code writing depends on the developer's structure of
functions and types to be reusable by other package modules. To achieve generic code templating in Golang, it's essential to have
generic type syntax to write effective functions to be used by common type sets. The generic code structure improves the design thinking
to write arbitrary functions for a critical implementation to create a common package module. Also, developers must understand the SOLID design
principle before jumping toward the generic design. It encourages arranging the GO programs to achieve a single-purpose design with the package
modules to work together.


SOLID principle design with interface

Interface represents any type in Go. It's best to define an interface with a function signature that any type can implement as an abstraction
to the package module. The interface provides segregation design principles that each type takes advantage of the method signature to write the
underlying function implementation based on the type.


Example:

Let's take an example of a simple Login package design. There are two user type logins { Employee, Customer }, to the Go applications, and
each type will do the login differently than the other. As the first approach, let's design the interface with the Login method signature.


`````````go
type Auth interface {
    Login(id, passwd string) error
}
`````````

The Auth interface defines a simple Login method with `id` and `password` parameters and returns an error. The `Employee` and `Customer`
types can utilize the `Auth` interface to write the implementation for Login.


````````go
type Employee struct {}

func newEmployee() Auth {
    return &Employee{}
}

func (e *Employee) employeeLogin(id, passwd string) error {
    // do employee login with the proper auth mechanism.
    return nil
}

func (e *Employee) Login(id, passwd string) error {
    fmt.Println("Employee login")

    if e.employeeLogin(id, passwd) != nil {
        return fmt.Errorf("employee login failed, id=%s", id)
    }

    return nil
}

type Customer struct {}

func newCustomer() Auth {
    return &Customer{}
}

func isLicenseEnabled(id string) bool {
    // complete code is not necessary
    return true
}

func (c *Customer) customerLogin(id, passwd string) error {
    // do customer login with the proper auth mechanism.
    return nil
}

func (c *Customer) Login(id, passwd string) error {
    fmt.Println("Customer login")

    if c.customerLogin(id, passwd) != nil {
        return fmt.Errorf("customer login failed, id=%s", id)
    }

    if isLicenseEnabled(id) {
        return nil
    }

    return fmt.Errorf("customer license is not enabled, id=%s", id)
}
````````


<< diagram >>

``````

 type Auth interface {
    Login(id, passwd string) error
 }    

 func (Employee) Login(id, passwd string) {}
 func (Customer) Login(id, passwd string) {}


In the example, the `Login` function use case is written differently for the `Employee` and `Customer` types.
The code structure shows by applying the interface segregation principle, each type can isolate the function
use case.

The `Auth` interface defines a single responsibility design by providing a single method signature. This common interface pattern is used widely in Go programs
for better maintainability and reusability of the package module and has a strict correlation among types to utilize the signatures and parameters of the methods.
But what if we have a use case to restrict the `Login` function to only a few types [Employee, Customer], and the caller MUST pass the parameters with the defined types?
Then, `interface` will not be the right approach to the problem.

We will dive into a similar kind of problem in the course of this article and how Golang generic will be the right way to implement the design.


Generic Design

The function parameters and arguments are instantiated in generic programming as a singular type to satisfy one common use case.
In Go 1.18+, the interface design allows the forming of a set of unions with non-interface types. It will be permitted as type parameters
to be used as function arguments as any other type.

Let's example of the Login function and refactor with Generic Type sets.

   func(Employee) Login(id, passwd string) error { return nil }
   func(Customer) Login(id, passwd string) error { return nil }

  We have two types to write as abstract data types, so we can define a new interface type to unionize the non-interface types.


   type AuthParameter interface {
   	    Employee | Customer | Admin // Added additional Admin struct type to explain better on the design
   }

  The `AuthParameter` creates an abstract data type better known as "type parameter". And it can use as type argument in the `Login` function.


  type Login[P AuthParameter] func(ctx context.Context, p P) error

  The `Login` function creates a generic function signature with `AuthParameter` as a type-parameter used as type argument P. Also, we can add as many
  type parameters to define an effective function signature as possible.

  Let's try adding one more type parameter that'll work as a return value for the function.


  type Login[P AuthParameter, T AuthClaimResponse] func(ctx context.Context, p P) (T, error)

  The new type parameter `AuthClaimResponse` in the modified function signature will work as a return type argument. Again, non-interface type can be
  anything to specify with the type parameter to apply to the use case.

  `````````
  type AuthClaimResponse interface {
  	*GeneralClaimResponse | *AdminClaimResponse
  }
  `````````

 `````````````````````
  type GeneralClaimResponse struct {
  	Id         string
  	Token      string
  	License    string
  	MemberType MemberType
  	*ErrorResponse
  }

  type AdminClaimResponse struct {
  	Id         string
  	Token      string
  	ACL        ACL
  	MemberType MemberType
  	Active     bool
  	*ErrorResponse
  }
  ``````````````````

    Now, let's look at the refactored `Login` function with generic programming and the problem we solve with the previous design.

    In the first code snippet for the `Employee` type, the `Login` set the type-parameter for the return arguments with `GeneralClaimResponse` and the implementation
    of the `employeeLoginFn` remains internal to the type and can process the inputs to return the required `GeneralClaimResponse` to the caller.

    `````````````````````
    req := Employee{AuthReq: AuthReq{Id: id, Password: password}}
    loginFn := Login[Employee, *GeneralClaimResponse](employeeLoginFn)
    employeeLoginFn := func(ctx context.Context, emp Employee) (*GeneralClaimResponse, error) {
        // TODO: do something with the function inputs
        return &GeneralClaimResponse{}, nil
    }
    `````````````````````

    For another concrete type, `Admin,` the type-parameter is declared with `AdminClaimResponse` to be used as the return value for the Login function. And for
    `adminLoginFn` function implementation remains independent of the other types.

    `````````````````````
    req := Admin{AuthReq: AuthReq{Id: id, Password: password}}
    loginFn := Login[Admin, *AdminClaimResponse](adminLoginFn)
    adminLoginFn := func(ctx context.Context, admin Admin) (*AdminClaimResponse, error) {
        // TODO: do something with the function inputs
        return &AdminClaimResponse{}, nil
    }
    `````````````````````

    Both types have their own `Login` function definition, and we need middleware to process them individually without additional value manipulation with type inputs.

    // Login function pass to the middleware
    resp, err := authMiddleware(ctx, loginFn, req)

    func authMiddleware[P AuthParameter, R AuthClaimResponse](
    	ctx context.Context,
    	loginFn Login[P, R], authReq P) (R, error) {
    	var retry = 5
    	return loginWithRetry(ctx, retry, loginFn, authReq)
    }

    func loginWithRetry[P AuthParameter, R AuthClaimResponse](
    	ctx context.Context,
    	retry int,
    	loginFn Login[P, R], authReq P) (R, error) {
    	resp, err := loginFn(ctx, authReq)
    	if err != nil {
    		if retry--; retry >= 0 {
    			return loginWithRetry(ctx, retry, loginFn, authReq)
    		}

    		return nil, err
    	}

    	fmt.Println("login successful ")

    	return resp, nil
    }

    We see a retry mechanism inside the middleware applied to the `Login` function. As the function definition is passed from the caller with the
    proper type arguments, the function can be retried by comparing each attempt with the error value. This is the least we can do for the `Login` function
    in the middleware; otherwise, the generic design doesn't yet support accessing field items of the `type` declared in the type argument.

    What problem did we solve with the Generic `Login` function design?
    - As we can see, the refactored `Login` function has type parameters with any concrete types, and each of them can define the implementation with their required
    type and prepare different outputs for the return arguments.
    - The generic retry component in the middleware allows the design to add a common retriable mechanism for the `Login` function.
    - The generic type parameters will allow adding any other concrete type to the design without intervening with core structural design changes.

 Constraints

  The type-parameter design adds a union of type sets to define an abstract data type, but we can't really know what types are involved in the set and how
  they operate to perform specific tasks. What if There is a requirement to write an arbitrary function to compare the type elements? It's essential to know the
  supported flavors of the types. Although the goal is to achieve a generic template to hide the type's behaviors, in some cases, it's good to use predictive type
  sets to add computational flexibility to the generic function. This is where Golang constraint design comes with defined type parameters to perform computation
  with Go operators.

  For example:

   package main

   import (
   	"fmt"
   	"golang.org/x/exp/constraints"
   )

   func main() {
   	sum1 := computeSum([]int{1, 2, 3, 4, 5})
   	fmt.Println("sum of integers = ", sum1)

   	sum2 := computeSum([]uint32{11, 21, 34, 41, 56})
   	fmt.Println("sum of unsigned integers = ", sum2)

   	result := compareFloats([]float64{1.5, 3.2, 4.7, 5.2, 8.9, 7.1, 6.3})
   	fmt.Println("float values greater than 5.0 = ", result)
   }

   func computeSum[P constraints.Integer](p []P) P {
   	var s P
   	for _, t := range p {
   		s += t
   	}
   	return s
   }

   func compareFloats[P constraints.Float](p []P) []P {
   	e := make([]P, 0, len(p))
   	for _, t := range p {
   		if t >= 5.0 {
   			e = append(e, t)
   		}
   	}
   	return e
   }

   In the example above, we imported the constraint package that provides known primitive data types declared as type parameters and that we can use to apply
   operators to perform math comparisons with the types. The constraint package allows flexibility to be compatible with the operators as the type elements are known.

   Also, we can define our constraint type parameters to perform a specific operation in the generic function. Let's take a simple use case to convert an array of
   strings to lowercase. In usual type-parameter declarations, we never know whether the type T is a string, and it's impossible to do the conversion. To overcome the
   design restriction, we can write an interface type `StringCases` to define the "ToLower() string" method signature, and then any concrete type can utilize the
   interface function internally to do string conversion. In the generic function, we can use the `StringCases` interface type as a type parameter to allow the type
   arguments to call the "ToLower()" function.

   package main

   import (
      "fmt"
      "strings"
   )

   func main() {
        str := ToLower([]res{{"ABC"}, {"DEF"}, {"PQR"}, {"XYZ"}})
        fmt.Println("convert string to lowercase = ", str)
   }

   type StringCases interface {
   	ToLower() string
   	ToUpper() string
   }

   type res struct {
   	x string
   }

   func (p res) ToLower() string {
   	return strings.ToLower(p.x)
   }

   func (p res) ToUpper() string {
   	return strings.ToUpper(p.x)
   }

   func ToLower[T StringCases](s []T) (ret []string) {
   	for _, v := range s {
   		ret = append(ret, v.ToLower())
   	}
   	return ret
   }


==========

// https://go.dev/play/p/DvJt4-rnTN5
